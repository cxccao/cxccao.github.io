{"title":"关于并发","date":"2020-07-13T12:46:48.000Z","date_formatted":{"ll":"2020年7月13日","L":"2020/07/13","MM-DD":"07-13"},"link":"2020/07/13/关于并发","tags":["Java并发"],"updated":"2020-07-30T08:22:51.425Z","content":"<h1 id=\"关于并发\">关于并发<a href=\"#关于并发\" title=\"关于并发\"></a></h1><h2 id=\"synchronized\">synchronized<a href=\"#synchronized\" title=\"synchronized\"></a></h2><h3 id=\"概念\">概念<a href=\"#概念\" title=\"概念\"></a></h3><p>被 <strong>synchronized</strong> 修饰的方法或代码块在任意时刻只能被一个线程执行。</p>\n<h3 id=\"使用方式\">使用方式<a href=\"#使用方式\" title=\"使用方式\"></a></h3><ul><li>修饰实例方法：作用域当前对象实例加锁，进入同步代码前要获得当前实例的锁</li>\n<li>修饰静态方法：给当前类加锁。会作用类的所有对象实例，因为静态成员不属于任何一个实例。<strong>访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。</li>\n<li>修饰代码块：进入同步代码块前要获得给定对象的锁。</li>\n</ul><h3 id=\"原理\">原理<a href=\"#原理\" title=\"原理\"></a></h3><p><strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong> 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor（monitor 对象存在于每个 Java 对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么 Java 中任意对象可以作为锁的原因）的持有权。当计数器为 0 则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>\n<p><strong>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识</strong>，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>\n<h3 id=\"优化\">优化<a href=\"#优化\" title=\"优化\"></a></h3><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p>\n<p>锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>\n<p><strong>偏向锁</strong>，会偏向第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步。</p>\n<p><strong>轻量级锁</strong>，加锁解锁都是 CAS 操作。</p>\n<p><strong>自旋锁</strong>，自旋等待，默认 10 次。</p>\n<p><strong>重量级锁</strong>，监视器锁（monitor 锁），直接对应 MutexLock，引起内核态和用户态的切换、线程阻塞等。</p>\n<h3 id=\"和reentrantlock的区别\">和ReentrantLock的区别<a href=\"#和reentrantlock的区别\" title=\"和ReentrantLock的区别\"></a></h3><p><strong>两者都是可重入锁</strong></p>\n<p>自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>\n<p><strong>synchronized是 JVM 层面，ReentrantLock 是 API 层面。</strong></p>\n<p><strong>ReentrantLock 比 synchronized 多了些功能</strong></p>\n<ul><li>等待可中断</li>\n<li>可实现公平锁</li>\n<li>可实现选择性通知</li>\n</ul><h2 id=\"volatile\">volatile<a href=\"#volatile\" title=\"volatile\"></a></h2><p>Java内存模型（Java Memory Model，JMM），描述了Java程序中各种变量的访问规则，以及在 JVM 中将变量存储到内存和从内从中读取变量这样的底层细节。</p>\n<img src=\"/2020/07/13/%E5%85%B3%E4%BA%8E%E5%B9%B6%E5%8F%91/JMM.png\" class=\"\"><p>这样的机制导致了可见性问题，即线程无法访问到其他线程本地内存中的变量。若线程 A 要和线程 B 通信，需经历以下步骤：</p>\n<ol><li>线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中。</li>\n<li>线程 B 到主内存读取线程 A 更新过的共享变量</li>\n</ol><h3 id=\"可见性\">可见性<a href=\"#可见性\" title=\"可见性\"></a></h3><ul><li>volatile 写：当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。</li>\n<li>volatile 读：当读一个 volatile 变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li>\n</ul><p>声明了 volatile  的变量进行写操作，JVM 会向处理器发送一条 Lock 前缀指令，将这个变量所在缓存行的数据写回到系统内存。但是此时其他处理器缓存的值还是旧的。</p>\n<p>所以为了保证各个处理器的缓存是一样的，需要实现<strong>缓存一致性协议</strong>，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新将系统内存中把数据读到处理器缓存里。</p>\n<p>但是，因为缓存一致性协议，volatile 变量需要不断从主内存嗅探，大量无效的交互会导致<strong>总线风暴</strong>，即总线带宽达到峰值。所以不要大量使用 volatile。</p>\n<p>可见性的另一个解决方法是加锁。为啥加锁可以解决可见性问题？因为某个线程进入 synchronized 代码块，线程会获得锁，清空本地内存，从主内存中拷贝共享变量最新值到本地内存作为副本，再执行代码。</p>\n<h3 id=\"指令重排序\">指令重排序<a href=\"#指令重排序\" title=\"指令重排序\"></a></h3><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段</p>\n<p>如果一个操作执行的结果需要对另一个操作可见，那这两个操作必须存在 happens-before 关系。as-if-serial 语义规定：不管怎么重排序，（单线程）程序的执行结果不能被改变。</p>\n<p>指令重排序在单线程是安全的，但在多线程下不一定。</p>\n<p>JMM 对编译器指定的 volatile 重排序规则表如下：</p>\n<div class=\"φcz\"><div class=\"φdb\"><table><thead><tr>\n<th align=\"center\">是否能重排序</th><th align=\"center\">第二个操作</th><th align=\"center\">第二个操作</th><th align=\"center\">第二个操作</th></tr>\n</thead><tbody><tr>\n<td align=\"center\"><strong>第一个操作</strong></td><td align=\"center\">普通读/写</td><td align=\"center\">volatile 读</td><td align=\"center\">volatile 写</td></tr>\n<tr>\n<td align=\"center\">普通读/写</td><td align=\"center\"></td><td align=\"center\"></td><td align=\"center\">×</td></tr>\n<tr>\n<td align=\"center\">volatile 读</td><td align=\"center\">×</td><td align=\"center\">×</td><td align=\"center\">×</td></tr>\n<tr>\n<td align=\"center\">volatile 写</td><td align=\"center\"></td><td align=\"center\">×</td><td align=\"center\">×</td></tr>\n</tbody></table></div></div><p>从表中我们可以看出：</p>\n<ul><li>volatile 写之前的操作不会被编译器重排序到 volatile 写之后</li>\n<li>volatile 读之后的操作不会被编译器重排序到 volatile 读之后</li>\n<li>当第一个操作是 volatile 写，第二个操作是 volatile 读，不能重排序</li>\n</ul><p>为了实现该规则，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。JMM 采取保守策略。</p>\n<ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障</li>\n<li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障</li>\n<li>在每个 volatile 读操作的前面插入一个 LoadLoad 屏障</li>\n<li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障</li>\n</ul><p>这种 XY 形式的语义是：在 XY 之前的 X 操作，不能与 XY 之后的 Y 操作进行重排序</p>\n<p>可以保证在任意处理器平台、任意程序中都能得到正确的 volatile 语义。</p>\n<h4 id=\"原子性\">原子性<a href=\"#原子性\" title=\"原子性\"></a></h4><p>volatile 不能保证数据原子性。</p>\n<p>num++ 操作对应的字节码，被拆分为3个指令：</p>\n<ol><li>GETFIELD 拿到主内存中的 num</li>\n<li>IADD 进行加 1 操作</li>\n<li>PUTFIELD 把本地内存中的值刷回主内存</li>\n</ol><p>当多个线程并发执行 PUTFIELD 指令时，会出现写回主内存覆盖问题。</p>\n<p>要原子性，就老老实实加锁，或者用 atomic 包。</p>\n<h2 id=\"线程池\">线程池<a href=\"#线程池\" title=\"线程池\"></a></h2><h3 id=\"为什么要用线程池\">为什么要用线程池<a href=\"#为什么要用线程池\" title=\"为什么要用线程池\"></a></h3><ul><li><strong>降低资源消耗</strong>。重用已创建的线程，减少频繁创建销毁线程的资源消耗。</li>\n<li><strong>提高响应速度</strong>。有任务使用线程时无需等待线程创建，拿来即用。</li>\n<li><strong>控制并发数量</strong>。并发数量过多可能导致资源不足而崩溃。</li>\n<li><strong>提高线程可管理性</strong>。统一分配线程，调优和监控。</li>\n</ul><h3 id=\"runnable接口和callable接口\">Runnable接口和Callable接口<a href=\"#runnable接口和callable接口\" title=\"Runnable接口和Callable接口\"></a></h3><p>Runnable接口不会返回结果或抛出检查异常；Callable接口可以。</p>\n<h3 id=\"创建\">创建<a href=\"#创建\" title=\"创建\"></a></h3><h4 id=\"executors\">Executors<a href=\"#executors\" title=\"Executors\"></a></h4><p>尽量不要。《阿里巴巴Java开发手册》强制线程池不允许使用Executors创建。</p>\n<blockquote>\n<ul><li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致OOM。</li>\n<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</li>\n</ul></blockquote>\n<h4 id=\"threadpoolexecutor\">ThreadPoolExecutor<a href=\"#threadpoolexecutor\" title=\"ThreadPoolExecutor\"></a></h4><p>参数：</p>\n<ul><li>coolPoolSize（核心线程数）</li>\n<li>maximumPoolSize（最大线程数）</li>\n<li>keepAliveTime（非核心线程的存活时间)</li>\n<li>TimeUnit（时间单位）</li>\n<li>workQueue（队列）</li>\n<li>threadFactory（创建线程的工厂）</li>\n<li>handler （拒绝策略/饱和策略）<ul><li>AbortPolicy：抛出异常拒绝</li>\n<li>CallerRunsPolicy：直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务</li>\n<li>DiscardPolicy：不处理，丢弃</li>\n<li>DiscardOldestPolicy：丢弃最早的未处理的任务</li>\n</ul></li>\n</ul><h2 id=\"aqs\">AQS<a href=\"#aqs\" title=\"AQS\"></a></h2><p>AbstractQueuedSynchronizer，抽象队列式同步器，用来构建锁和同步器的框架，ReentrantLock 是基于AQS的。</p>\n<h3 id=\"核心思想\">核心思想<a href=\"#核心思想\" title=\"核心思想\"></a></h3><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制。这个机制是用CLH队列锁，即将暂时获取不到锁的线程加入到队列中。</p>\n<img src=\"/2020/07/13/%E5%85%B3%E4%BA%8E%E5%B9%B6%E5%8F%91/AQS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png\" class=\"\"><p>使用了一个volatile的变量state来作为资源的标识。状态信息通过 protected 类型的<code>getState</code>，<code>setState</code>，<code>compareAndSetState</code>进行操作</p>\n<h3 id=\"共享方式\">共享方式<a href=\"#共享方式\" title=\"共享方式\"></a></h3><ul><li>Exclusive（独占）：只有一个线程能执行，如 ReentrantLock。可分为公平锁和非公平锁。</li>\n<li>Share（共享）：多个线程可同时进行，如 CountDownLatch、CyclicBarrier。</li>\n</ul><h3 id=\"模板方法模式\">模板方法模式<a href=\"#模板方法模式\" title=\"模板方法模式\"></a></h3><p>AQS的设计基于模板方法模式。有些方法必须由子类去实现：</p>\n<ul><li><code>isHeldExclusively()</code>：该线程是否正在独占资源。只有用到 Condition 才需要去实现它。</li>\n<li><code>tryAcquire(int)</code>：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。</li>\n<li><code>tryRelease(int)</code>：独占方式。尝试释放资源，成功则返回 true，失败则返回 false。</li>\n<li><code>tryAcquireShared(int)</code>：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>\n<li><code>tryReleaseShared(int)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回 true，否则返回 false。</li>\n</ul><blockquote>\n<p>以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程<code>lock()</code>时，会调用<code>tryAcquire()</code>独占该锁并将 state + 1。此后，其他线程再<code>tryAcquire()</code>时就会失败，直到 A 线程<code>unlock()</code>到 state = 0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</p>\n</blockquote>\n<h3 id=\"组件\">组件<a href=\"#组件\" title=\"组件\"></a></h3><ul><li><strong>CountDownLatch （倒计时器）：</strong> CountDownLatch 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li>\n<li><strong>CyclicBarrier(循环栅栏)：</strong> CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li>\n</ul><h2 id=\"threadlocal\">ThreadLocal<a href=\"#threadlocal\" title=\"ThreadLocal\"></a></h2><p>ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景。</p>\n<p>// TODO，有空再研究下</p>\n","prev":{"title":"关于计算机网络","link":"2020/07/14/关于计算机网络"},"next":{"title":"快速失败和安全失败","link":"2020/07/13/快速失败和安全失败"},"plink":"https://cxccao.github.io/2020/07/13/关于并发/","toc":[{"id":"关于并发","title":"关于并发","index":"1","children":[{"id":"synchronized","title":"synchronized","index":"1.1","children":[{"id":"概念","title":"概念","index":"1.1.1"},{"id":"使用方式","title":"使用方式","index":"1.1.2"},{"id":"原理","title":"原理","index":"1.1.3"},{"id":"优化","title":"优化","index":"1.1.4"},{"id":"和reentrantlock的区别","title":"和ReentrantLock的区别","index":"1.1.5"}]},{"id":"volatile","title":"volatile","index":"1.2","children":[{"id":"可见性","title":"可见性","index":"1.2.1"},{"id":"指令重排序","title":"指令重排序","index":"1.2.2"}]},{"id":"线程池","title":"线程池","index":"1.3","children":[{"id":"为什么要用线程池","title":"为什么要用线程池","index":"1.3.1"},{"id":"runnable接口和callable接口","title":"Runnable接口和Callable接口","index":"1.3.2"},{"id":"创建","title":"创建","index":"1.3.3"}]},{"id":"aqs","title":"AQS","index":"1.4","children":[{"id":"核心思想","title":"核心思想","index":"1.4.1"},{"id":"共享方式","title":"共享方式","index":"1.4.2"},{"id":"模板方法模式","title":"模板方法模式","index":"1.4.3"},{"id":"组件","title":"组件","index":"1.4.4"}]},{"id":"threadlocal","title":"ThreadLocal","index":"1.5"}]}],"copyright":{"author":"Shelton Chen","link":"<a href=\"https://cxccao.github.io/2020/07/13/关于并发/\" title=\"关于并发\">https://cxccao.github.io/2020/07/13/关于并发/</a>","updated":"2020年7月30日","license":"署名-非商业性使用-相同方式共享 4.0 国际 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)"}}