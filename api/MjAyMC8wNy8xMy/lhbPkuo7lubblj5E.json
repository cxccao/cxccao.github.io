{"title":"关于并发","date":"2020-07-13T12:46:48.000Z","date_formatted":{"ll":"2020年7月13日","L":"2020/07/13","MM-DD":"07-13"},"link":"2020/07/13/关于并发","tags":["Java并发"],"updated":"2020-07-14T08:26:06.020Z","content":"<h1 id=\"关于并发\">关于并发<a href=\"#关于并发\" title=\"关于并发\"></a></h1><h2 id=\"synchronized\">synchronized<a href=\"#synchronized\" title=\"synchronized\"></a></h2><h3 id=\"概念\">概念<a href=\"#概念\" title=\"概念\"></a></h3><p>被synchronized修饰的方法或代码块在任意时刻只能被一个线程执行。</p>\n<h3 id=\"使用方式\">使用方式<a href=\"#使用方式\" title=\"使用方式\"></a></h3><ul><li>修饰实例方法：作用域当前对象实例加锁，进入同步代码前要获得当前实例的锁</li>\n<li>修饰静态方法：给当前类加锁。会作用类的所有对象实例，因为静态成员不属于任何一个实例。<strong>访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。</li>\n<li>修饰代码块：进入同步代码块前要获得给定对象的锁。</li>\n</ul><h3 id=\"原理\">原理<a href=\"#原理\" title=\"原理\"></a></h3><p><strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong> 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>\n<p><strong>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识</strong>，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>\n<h3 id=\"优化\">优化<a href=\"#优化\" title=\"优化\"></a></h3><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p>\n<p>锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>\n<p><strong>偏向锁</strong>，会偏向第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步。</p>\n<p><strong>轻量级锁</strong>，加锁解锁都是CAS操作。</p>\n<p><strong>自旋锁</strong>，自旋等待，默认10次。</p>\n<p><strong>重量级锁</strong>，监视器锁（monitor锁），直接对应MutexLock，引起内核态和用户态的切换、线程阻塞等。</p>\n<h3 id=\"和reentrantlock的区别\">和ReentrantLock的区别<a href=\"#和reentrantlock的区别\" title=\"和ReentrantLock的区别\"></a></h3><p><strong>两者都是可重入锁</strong></p>\n<p>自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>\n<p><strong>synchronized是JVM层面，ReentrantLock是API层面。</strong></p>\n<p><strong>ReentrantLock比synchronized多了些功能</strong></p>\n<ul><li>等待可中断</li>\n<li>可实现公平锁</li>\n<li>可实现选择性通知</li>\n</ul><h2 id=\"volatile\">volatile<a href=\"#volatile\" title=\"volatile\"></a></h2><p>保证变量每次都从主内存中取</p>\n<ul><li><p>保证变量的<strong>内存可见性</strong></p>\n</li>\n<li><p>禁止指令<strong>重排序</strong></p>\n</li>\n</ul><p>volatile不能保证数据原子性</p>\n<h2 id=\"线程池\">线程池<a href=\"#线程池\" title=\"线程池\"></a></h2><h3 id=\"为什么要用线程池\">为什么要用线程池<a href=\"#为什么要用线程池\" title=\"为什么要用线程池\"></a></h3><ul><li><strong>降低资源消耗</strong>。重用已创建的线程，减少频繁创建销毁线程的资源消耗。</li>\n<li><strong>提高响应速度</strong>。有任务使用线程时无需等待线程创建，拿来即用。</li>\n<li><strong>控制并发数量</strong>。并发数量过多可能导致资源不足而崩溃。</li>\n<li><strong>提高线程可管理性</strong>。统一分配线程，调优和监控。</li>\n</ul><h3 id=\"runnable接口和callable接口\">Runnable接口和Callable接口<a href=\"#runnable接口和callable接口\" title=\"Runnable接口和Callable接口\"></a></h3><p>Runnable接口不会返回结果或抛出检查异常；Callable接口可以。</p>\n<h3 id=\"创建\">创建<a href=\"#创建\" title=\"创建\"></a></h3><h4 id=\"executors\">Executors<a href=\"#executors\" title=\"Executors\"></a></h4><p>尽量不要。《阿里巴巴Java开发手册》强制线程池不允许使用Executors创建。</p>\n<blockquote>\n<ul><li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致OOM。</li>\n<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</li>\n</ul></blockquote>\n<h4 id=\"threadpoolexecutor\">ThreadPoolExecutor<a href=\"#threadpoolexecutor\" title=\"ThreadPoolExecutor\"></a></h4><p>参数：</p>\n<ul><li>coolPoolSize（核心线程数）</li>\n<li>maximumPoolSize（最大线程数）</li>\n<li>keepAliveTime（非核心线程的存活时间)</li>\n<li>TimeUnit（时间单位）</li>\n<li>workQueue（队列）</li>\n<li>threadFactory（创建线程的工厂）</li>\n<li>handler （拒绝策略/饱和策略）<ul><li>AbortPolicy：抛出异常拒绝</li>\n<li>CallerRunsPolicy：直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务</li>\n<li>DiscardPolicy：不处理，丢弃</li>\n<li>DiscardOldestPolicy：丢弃最早的未处理的任务</li>\n</ul></li>\n</ul><h2 id=\"aqs\">AQS<a href=\"#aqs\" title=\"AQS\"></a></h2><p>AbstractQueuedSynchronizer，抽象队列式同步器，用来构建锁和同步器的框架，ReentrantLock是基于AQS的。</p>\n<h3 id=\"核心思想\">核心思想<a href=\"#核心思想\" title=\"核心思想\"></a></h3><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制。这个机制是用CLH队列锁，即将暂时获取不到锁的线程加入到队列中。</p>\n<img src=\"/2020/07/13/%E5%85%B3%E4%BA%8E%E5%B9%B6%E5%8F%91/AQS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png\" class=\"\"><p>使用了一个volatile的变量state来作为资源的标识。状态信息通过protected类型的<code>getState</code>，<code>setState</code>，<code>compareAndSetState</code>进行操作</p>\n<h3 id=\"共享方式\">共享方式<a href=\"#共享方式\" title=\"共享方式\"></a></h3><ul><li>Exclusive（独占）：只有一个线程能执行，如ReentrantLock。可分为公平锁和非公平锁。</li>\n<li>Share（共享）：多个线程可同时进行，如CountDownLatch、CyclicBarrier。</li>\n</ul><h3 id=\"模板方法模式\">模板方法模式<a href=\"#模板方法模式\" title=\"模板方法模式\"></a></h3><p>AQS的设计基于模板方法模式。有些方法必须由子类去实现：</p>\n<ul><li><code>isHeldExclusively()</code>：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>\n<li><code>tryAcquire(int)</code>：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>\n<li><code>tryRelease(int)</code>：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>\n<li><code>tryAcquireShared(int)</code>：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>\n<li><code>tryReleaseShared(int)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>\n</ul><blockquote>\n<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>\n</blockquote>\n<h3 id=\"组件\">组件<a href=\"#组件\" title=\"组件\"></a></h3><ul><li><strong>CountDownLatch （倒计时器）：</strong> CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li>\n<li><strong>CyclicBarrier(循环栅栏)：</strong> CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li>\n</ul>","prev":{"title":"关于计算机网络","link":"2020/07/14/关于计算机网络"},"next":{"title":"快速失败和安全失败","link":"2020/07/13/快速失败和安全失败"},"plink":"https://cxccao.github.io/2020/07/13/关于并发/","toc":[{"id":"关于并发","title":"关于并发","index":"1","children":[{"id":"synchronized","title":"synchronized","index":"1.1","children":[{"id":"概念","title":"概念","index":"1.1.1"},{"id":"使用方式","title":"使用方式","index":"1.1.2"},{"id":"原理","title":"原理","index":"1.1.3"},{"id":"优化","title":"优化","index":"1.1.4"},{"id":"和reentrantlock的区别","title":"和ReentrantLock的区别","index":"1.1.5"}]},{"id":"volatile","title":"volatile","index":"1.2"},{"id":"线程池","title":"线程池","index":"1.3","children":[{"id":"为什么要用线程池","title":"为什么要用线程池","index":"1.3.1"},{"id":"runnable接口和callable接口","title":"Runnable接口和Callable接口","index":"1.3.2"},{"id":"创建","title":"创建","index":"1.3.3"}]},{"id":"aqs","title":"AQS","index":"1.4","children":[{"id":"核心思想","title":"核心思想","index":"1.4.1"},{"id":"共享方式","title":"共享方式","index":"1.4.2"},{"id":"模板方法模式","title":"模板方法模式","index":"1.4.3"},{"id":"组件","title":"组件","index":"1.4.4"}]}]}],"copyright":{"author":"Shelton Chen","link":"<a href=\"https://cxccao.github.io/2020/07/13/关于并发/\" title=\"关于并发\">https://cxccao.github.io/2020/07/13/关于并发/</a>","updated":"2020年7月14日","license":"署名-非商业性使用-相同方式共享 4.0 国际 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)"}}