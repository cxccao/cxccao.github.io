{"title":"关于Java内存区域","date":"2020-07-11T14:06:43.000Z","date_formatted":{"ll":"2020年7月11日","L":"2020/07/11","MM-DD":"07-11"},"link":"2020/07/11/关于Java内存区域","tags":["JVM"],"updated":"2020-07-13T12:44:14.008Z","content":"<h1 id=\"关于java内存区域\">关于Java内存区域<a href=\"#关于java内存区域\" title=\"关于Java内存区域\"></a></h1><h2 id=\"运行时数据区域\">运行时数据区域<a href=\"#运行时数据区域\" title=\"运行时数据区域\"></a></h2><p>JVM在执行Java程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK1.8和之前的版本有不同。</p>\n<ul><li>运行时数据区域（1.8前）<ul><li>线程共享<ul><li>堆</li>\n<li>方法区<ul><li>运行时常量池（1.7时字符串常量池被单独拿到堆去了）</li>\n</ul></li>\n</ul></li>\n<li>线程私有<ul><li>虚拟机栈</li>\n<li>本地方法栈</li>\n<li>程序计数器</li>\n</ul></li>\n</ul></li>\n<li>运行时数据区域（1.8）<ul><li>线程共享<ul><li>堆（字符串常量池依然单独在这里）</li>\n</ul></li>\n<li>线程私有<ul><li>虚拟机栈</li>\n<li>本地方法栈</li>\n<li>程序计数器</li>\n</ul></li>\n<li>元空间<ul><li>运行时常量池</li>\n</ul></li>\n</ul></li>\n</ul><h3 id=\"名词解释\">名词解释<a href=\"#名词解释\" title=\"名词解释\"></a></h3><h4 id=\"程序计数器\">程序计数器<a href=\"#程序计数器\" title=\"程序计数器\"></a></h4><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。</li>\n<li>在多线程情况下，用于记录当前线程执行的位置，以保证线程切换时能找到上次运行位置。</li>\n</ol><h4 id=\"虚拟机栈\">虚拟机栈<a href=\"#虚拟机栈\" title=\"虚拟机栈\"></a></h4><p>由一个个栈帧组成（可视为函数或方法调用）。每个栈帧中都拥有：局部变量表，方法出口，操作数栈、动态链接等。局部变量表主要存放了编译器可直达的各种数据类型、对象引用。</p>\n<h4 id=\"本地方法栈\">本地方法栈<a href=\"#本地方法栈\" title=\"本地方法栈\"></a></h4><p>和虚拟机栈十分相似。不同在于，虚拟机栈为字节码服务，本地方法栈为虚拟机调用本地native方法服务。</p>\n<h4 id=\"堆\">堆<a href=\"#堆\" title=\"堆\"></a></h4><p>存放对象实例</p>\n<p>JDK1.7及以前被分为三块：新生代、老年代、永久代。到了1.8，永久代被取消了，取而代之的是元空间，元空间放在直接内存。</p>\n<ul><li>新生代<ul><li>Eden区</li>\n<li>Survivor区<ul><li>FromPlace</li>\n<li>ToPlace</li>\n</ul></li>\n</ul></li>\n</ul><p>当我们new一个对象后，会在Eden区分配。当Eden空间满了会触发Minor GC，存活下来的对象移动到s0区。s0区满后触发Minor GC，将存活对象移到s1区。每次都会交换from和to指针，所以一段时间内总有一个survivor区为空且to指向的survivor区为空。经过15次（对象头的标记字段里记录年龄，分配的空间只有4bit）Minor GC后仍存活的对象会移动到老年代。</p>\n<p>老年代占满时，会发生Full GC（Stop the world），当老年代GC完后仍无法进行对象保存的操作，就会产生OOM。</p>\n<h4 id=\"方法区\">方法区<a href=\"#方法区\" title=\"方法区\"></a></h4><p><strong>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong></p>\n<blockquote>\n<p><strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p>\n</blockquote>\n<p>整个永久代有JVM设置的固定大小上限，无法调整。而元空间只受本机可用内存限制。元空间也可使用<code>-XX:MaxMetaspaceSize</code>来设置最大元空间大小，默认不设置情况下只受可用内存限制。<code>-XX：MetaspaceSize</code>调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p>\n<p>在JDK1.8合并HotSpot和JRockit的代码时，JRockit没有永久代这个东西，所以就取消了。</p>\n<h4 id=\"运行时常量池\">运行时常量池<a href=\"#运行时常量池\" title=\"运行时常量池\"></a></h4><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）</p>\n<h2 id=\"对象\">对象<a href=\"#对象\" title=\"对象\"></a></h2><h3 id=\"对象的创建\">对象的创建<a href=\"#对象的创建\" title=\"对象的创建\"></a></h3><h4 id=\"类加载检查\">类加载检查<a href=\"#类加载检查\" title=\"类加载检查\"></a></h4><p>虚拟机遇到new后，先检查指令的参数是否能在常量池定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过，如果没有找到说明类还没被加载，执行类加载过程。</p>\n<h4 id=\"分配内存\">分配内存<a href=\"#分配内存\" title=\"分配内存\"></a></h4><p>类加载检查通过后，虚拟机为新生对象分配内存（堆中），分配方式有“指针碰撞”和“空闲列表”。选择哪种由堆是否规整决定。而堆是否规整又由垃圾收集器是否带有压缩整理功能决定。</p>\n<ul><li>指针碰撞<ul><li>场合：堆规整（没有内存碎片）</li>\n<li>原理：用过的内存全部整合到一边，没用过的放到另一边，中间有一个分界指针，只需要向着没用过的内存方向将指针移动对象内存的大小位置即可。</li>\n<li>垃圾收集器：Serial、ParNew</li>\n</ul></li>\n<li>空闲列表<ul><li>场合：堆不规整</li>\n<li>原理：虚拟机维护一个列表，列表记录哪些内存可用，分配时找一块足够大的内存块来划分对象实例，最后更新列表记录。</li>\n<li>垃圾收集器：CMS</li>\n</ul></li>\n</ul><p>因为堆是全局共享的，因此在同一时间，可能有多个线程在堆上申请空间，那么，在并发场景中，如果两个线程先后把对象引用指向了同一个内存区域，怎么办？</p>\n<ul><li>CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</li>\n<li>TLAB： 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行分配。</li>\n</ul><h4 id=\"初始化零值\">初始化零值<a href=\"#初始化零值\" title=\"初始化零值\"></a></h4><p>虚拟机将分配到的内存空间都初始化为零值（不包括对象头 ）。所以实例的字段不赋初值就可以直接使用（零值）。</p>\n<h4 id=\"设置对象头\">设置对象头<a href=\"#设置对象头\" title=\"设置对象头\"></a></h4><p>对象头主要包含两部分</p>\n<ul><li>储存对象自身的运行时数据，如hashcode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。</li>\n<li>类型指针，即对象指向它类元数据的指针。虚拟机通过这个指针确定这个对象是哪个类的实例。</li>\n<li>如果对象是一个数组，那么对象头还有额外空间用于储存数组长度。</li>\n</ul><h4 id=\"执行-init方法\">执行 init方法<a href=\"#执行-init方法\" title=\"执行 init方法\"></a></h4><p>Java对象在被创建时，会进行实例化操作。该部分操作封装在<init>方法中，并且子类的<init>方法中会首先对父类<init>方法的调用。Java对象实例化过程中对实例域的初始化赋值操作全部在<init>方法中进行，<init>方法显式的调用父类的<init>方法，实例域的声明以及实例初始化语句块同样的位置关系会影响编译器生成的<init>方法的字节码顺序，<init>方法以构造方法作为结束。</p>\n<h3 id=\"对象的内存布局\">对象的内存布局<a href=\"#对象的内存布局\" title=\"对象的内存布局\"></a></h3><p>在HotSpot中，可分为三块：对象头、示例数据、对齐填充。</p>\n<p>对齐填充部分不必然存在，仅起占位作用。因为HotSpot的自动内存管理系统要求对象起始地址必须是8字节的整数倍。所以没有对齐时就需要通过对其填充部分补全。</p>\n<h3 id=\"对象的访问定位\">对象的访问定位<a href=\"#对象的访问定位\" title=\"对象的访问定位\"></a></h3><p>程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定。主流的方式有两种</p>\n<ol><li>句柄： 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息</li>\n<li>堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</li>\n</ol><p>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p>\n<h2 id=\"附：关于常量池\">附：关于常量池<a href=\"#附：关于常量池\" title=\"附：关于常量池\"></a></h2><h3 id=\"string\">String<a href=\"#string\" title=\"String\"></a></h3><ul><li>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</li>\n<li>new，如果池中已存在该字符串常量，则只会在堆空间创建一个字符串常量。如果池中没有该字符串常量，那么它将首先在池中创建，然后在堆空间中创建。</li>\n<li>String.intern() 。如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用。</li>\n</ul><h3 id=\"基本类型的包装类\">基本类型的包装类<a href=\"#基本类型的包装类\" title=\"基本类型的包装类\"></a></h3><p>Byte,Short,Integer,Long创建了[-128,127]的缓存数据；Character创建了[0,127]的缓存数据；Boolean 直接返回True Or False。如果超出对应范围仍会创建新的对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i1 &#x3D; 40;</span><br><span class=\"line\">Integer i2 &#x3D; 40;</span><br><span class=\"line\">Integer i3 &#x3D; 0;</span><br><span class=\"line\">Integer i4 &#x3D; new Integer(40);</span><br><span class=\"line\">Integer i5 &#x3D; new Integer(40);</span><br><span class=\"line\">Integer i6 &#x3D; new Integer(0);</span><br></pre></td></tr></table></figure><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i1 &#x3D;&#x3D; i2          true（都指向常量池中的40）</span><br><span class=\"line\">i1 &#x3D;&#x3D; i2 + i3     true</span><br><span class=\"line\">i1 &#x3D;&#x3D; i4          false（“&#x3D;&#x3D;”两边没出现运算符，不会自动拆箱）</span><br><span class=\"line\">i4 &#x3D;&#x3D; i5          false</span><br><span class=\"line\">i4 &#x3D;&#x3D; i5 + i6     true（出现运算符，拆箱）</span><br><span class=\"line\">40 &#x3D;&#x3D; i5 + i6     true</span><br></pre></td></tr></table></figure>","prev":{"title":"关于JVM垃圾回收","link":"2020/07/12/关于JVM垃圾回收"},"next":{"title":"关于ConcurrentHashMap","link":"2020/07/11/关于ConcurrentHashMap"},"plink":"https://cxccao.github.io/2020/07/11/关于Java内存区域/","toc":[{"id":"关于java内存区域","title":"关于Java内存区域","index":"1","children":[{"id":"运行时数据区域","title":"运行时数据区域","index":"1.1","children":[{"id":"名词解释","title":"名词解释","index":"1.1.1"}]},{"id":"对象","title":"对象","index":"1.2","children":[{"id":"对象的创建","title":"对象的创建","index":"1.2.1"},{"id":"对象的内存布局","title":"对象的内存布局","index":"1.2.2"},{"id":"对象的访问定位","title":"对象的访问定位","index":"1.2.3"}]},{"id":"附：关于常量池","title":"附：关于常量池","index":"1.3","children":[{"id":"string","title":"String","index":"1.3.1"},{"id":"基本类型的包装类","title":"基本类型的包装类","index":"1.3.2"}]}]}],"copyright":{"author":"Shelton Chen","link":"<a href=\"https://cxccao.github.io/2020/07/11/关于Java内存区域/\" title=\"关于Java内存区域\">https://cxccao.github.io/2020/07/11/关于Java内存区域/</a>","updated":"2020年7月13日","license":"署名-非商业性使用-相同方式共享 4.0 国际 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)"}}