{"title":"关于计算机网络","date":"2020-07-14T11:31:08.000Z","date_formatted":{"ll":"2020年7月14日","L":"2020/07/14","MM-DD":"07-14"},"link":"2020/07/14/关于计算机网络","tags":["计算机网络"],"updated":"2020-07-20T14:29:03.456Z","content":"<h1 id=\"计算机网络\">计算机网络<a href=\"#计算机网络\" title=\"计算机网络\"></a></h1><h2 id=\"网络层次\">网络层次<a href=\"#网络层次\" title=\"网络层次\"></a></h2><p>OSI将网络分为七层，TCP/IP有四层，折中取五层</p>\n<img src=\"/2020/07/14/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png\" class=\"\"><ol><li>物理层：主要定义物理设备标准，例如网线的接口类型、光线的接口类型、各种传输介质的传输速率等。他的主要作用是传入比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们通常所说的数模转换与模数转换）。这一层的数据叫做比特流。（RJ45、IEEE802.3）</li>\n<li>数据链路层：定义了如何让数据格式化进行传输，以及如何让控制对物理介质的访问。这一层通常还提供了错误检测和纠正，以保证数据的可靠传输。（VLAN、MAC）</li>\n<li>网络层：在位于不同地理位置的网络中的两个主机之间提供连接和路径选择。（IP、ICMP、ARP）</li>\n<li>传输层：定义了一些传输数据的协议和端口号（TCP、UDP）</li>\n<li>应用层：通过进程间的交互来完成特定网应用。（HTTP、DNS、FTP）</li>\n</ol><h2 id=\"tcpip\">TCP/IP<a href=\"#tcpip\" title=\"TCP/IP\"></a></h2><h3 id=\"三次握手和四次挥手原理\">三次握手和四次挥手原理<a href=\"#三次握手和四次挥手原理\" title=\"三次握手和四次挥手原理\"></a></h3><ul><li><p>三次握手：客户端发送请求连接数据报，首部 SYN = 1，序列号 x，进入 SYN-SENT 状态；服务器同意请求，发送同意连接数据报，首部 SYN = 1，ACK = 1，序列号 y，确认号 x + 1，进入 SYN-RECV 状态；客户端发送确认数据报，ACK = 1，序列号 x + 1，确认号 y + 1，进入 ESTABLISHED 状态；服务器收到数据报，进入 ESTABLISHED 状态。至此双方已建立链接。</p>\n</li>\n<li><p>四次挥手：客户端发送释放连接数据报，首部 FIN = 1，序列号 u，进入 FIN-WAIT-1状态；服务器发出确认数据报，首部 ACK = 1，序列号  v，确认号 u + 1，进入 CLOSED-WAIT 状态；客户端进入FIN-WAIT-2状态；服务器发送完最后的数据后，发出释放连接数据报，首部 FIN = 1，ACK = 1，序列号 w，确认号 u + 1，进入 LAST-ACK状态；客户端发送确认数据报，首部 ACK = 1，序列号 u + 1，确认号  w + 1，进入TIME-WAIT状态；服务器进入CLOSED状态；客户端等待2MSL后，进入CLOSED状态。至此双方结束链接。</p>\n</li>\n</ul><h3 id=\"为什么要三次握手？\">为什么要三次握手？<a href=\"#为什么要三次握手？\" title=\"为什么要三次握手？\"></a></h3><p>很遗憾，网上许多介绍都是想当然的错误而已。三次握手并不是要确认自己和对方的发送和接收正常。读一下<a href=\"https://www.ietf.org/rfc/rfc793.txt\" target=\"_blank\">RFC793</a>（TCP传输控制协议），可以发现在3.3 Sequence Numbers中讲到了：</p>\n<blockquote>\n<p>A fundamental notion in the design is that every octet of data sent over a TCP connection has a sequence number. Since every octet is sequenced, each of them can be acknowledged. The acknowledgment mechanism employed is cumulative so that an acknowledgment of sequence number X indicates that all octets up to but not including X have been received.</p>\n</blockquote>\n<p>TCP可靠连接有许多原因，最主要的就是这条：序列号。</p>\n<blockquote>\n<p>A three way handshake is necessary because sequence numbers are not tied to a global clock in the network, and TCPs may have different mechanisms for picking the ISN’s. The receiver of the first SYN has no way of knowing whether the segment was an old delayed one or not, unless it remembers the last sequence number used on the connection (which is not always possible), and so it must ask the sender to verify this SYN. The three way handshake and the advantages of a clock-driven scheme are discussed in [3].</p>\n</blockquote>\n<p>所以，三次握手的真正原因是：<strong>TCP 需要序列号（seq）来做可靠重传或接收，而避免连接复用时无法分辨出序列号是延迟或者是旧链接的序列号，因此需要三次握手来约定确定双方的 Initial Sequence Number（初始序列号）。</strong></p>\n<h3 id=\"为什么是四次挥手、为什么要等待2msl？\">为什么是四次挥手、为什么要等待2MSL？<a href=\"#为什么是四次挥手、为什么要等待2msl？\" title=\"为什么是四次挥手、为什么要等待2MSL？\"></a></h3><p>TCP是全双工通信，故每一个方向都必须单独进行关闭。当一方完毕它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN仅仅意味着这一方向上没有数据流动。一个TCP连接在收到一个FIN后仍能发送数据。</p>\n<p>保证客户端发送的最后一个ACK报文能够到达服务器。服务器已经发送了FIN+ACK报文请求断开了，客户端还没有回应，应该是发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器；在这个2MSL时间中，可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>\n<h3 id=\"如何保证可靠传输\">如何保证可靠传输<a href=\"#如何保证可靠传输\" title=\"如何保证可靠传输\"></a></h3><ul><li>数据被TCP分割成最适合的大小</li>\n<li><strong>序列号！！！</strong></li>\n<li>校验和 </li>\n<li>流量控制</li>\n<li>拥塞控制</li>\n<li>超时重传</li>\n<li>ARQ协议</li>\n</ul><h3 id=\"流量控制\">流量控制<a href=\"#流量控制\" title=\"流量控制\"></a></h3><p>为了控制发送方发送速率，保证接收方来得及接收。</p>\n<p>TCP通过滑动窗口来实现流量控制。 </p>\n<p>接收方发送的确认报文中的窗口字段可以用来告诉发送方窗口大小，从而影响发送方的发送速率。将窗口置零，则发送方不能发送数据。</p>\n<h3 id=\"拥塞控制\">拥塞控制<a href=\"#拥塞控制\" title=\"拥塞控制\"></a></h3><p>TCP发送方维护一个拥塞窗口（cwnd）变量。动态变化。采用四种算法来控制：<strong>慢开始</strong>、<strong>拥塞避免</strong>、<strong>快重传、</strong>快恢复**。</p>\n<ul><li>慢开始：cwnd初始值为1，每经过一个传播轮次，cwnd翻倍。设置一个慢开始阈值 ssthresh。</li>\n<li>拥塞避免：cwnd &gt;= ssthresh 时采用。每经过一个传播轮次，cwnd 线性加一。</li>\n<li>快重传：发送方尽快进行重传，而不是等超时重传计时器超时再重传；要求接收方收到数据立即发送确认；接收方收到失序的报文段立即发出已收到报文段的重复确认；发送方收到3个连续的重复确认，就将缺失的报文段立即重传。</li>\n<li>快恢复：将 cwnd 和 ssthresh 调整为当前窗口一半，开始拥塞避免算法。</li>\n</ul><h3 id=\"和udp区别\">和UDP区别<a href=\"#和udp区别\" title=\"和UDP区别\"></a></h3><p>TCP：面向连接、可靠、资源开销多</p>\n<p>UDP：无连接、不可靠、资源开销少</p>\n<h2 id=\"http和https\">HTTP和HTTPS<a href=\"#http和https\" title=\"HTTP和HTTPS\"></a></h2><h3 id=\"http10和http11区别\">HTTP/1.0和HTTP/1.1区别<a href=\"#http10和http11区别\" title=\"HTTP/1.0和HTTP/1.1区别\"></a></h3><ul><li>在HTTP/1.0中默认使用短连接，每一次请求都需要重新建立连接（需要三握四挥开销）；HTTP/1.1默认使用长连接，默认开启keep-alive，有非流水线和流水线方式，前者收到响应后才能发送下一个请求，后者能连续发送请求。</li>\n<li>HTTP/1.1新增24个状态响应码</li>\n<li>HTTP/1.0是哟个If-Modified-Since、Expires来做缓存判断标准；HTTP/1.1使用新增如Entity tag、If-Unmodified-Since、If-Match、If-None-Match来控制缓存策略。</li>\n<li>HTTP/1.0中请求资源必须请求整个资源；HTTP/1.1中在header中加入了range头域，允许只请求资源的某个部分。</li>\n</ul><h3 id=\"http和https的区别\">HTTP和HTTPS的区别<a href=\"#http和https的区别\" title=\"HTTP和HTTPS的区别\"></a></h3><ul><li>HTTPS协议需要到CA申请证书。</li>\n<li>HTTP协议运行在TCP之上，所有传输内容都是明文；HTTPS运行在SSL/TLS上，SSL/TLS运行在TCP之上，所有传输内容都经过加密。</li>\n<li>HTTP端口为80；HTTPS端口为443。</li>\n<li>HTTPS比HTTP更消耗资源。</li>\n</ul><h3 id=\"http报文结构\">HTTP报文结构<a href=\"#http报文结构\" title=\"HTTP报文结构\"></a></h3><ul><li>请求行/响应行：Method Request-URI HTTP-Version；HTTP-Version Status-Code Reason-Phrase</li>\n<li>请求头/响应头：Host、User-Agent、Accept…；Location、Server…</li>\n<li>报文主体</li>\n</ul><h3 id=\"https流程\">HTTPS流程<a href=\"#https流程\" title=\"HTTPS流程\"></a></h3><img src=\"/2020/07/14/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS%E6%B5%81%E7%A8%8B.png\" class=\"\"><ul><li>对称加密：加密和解密都是用同一个密钥。（DES、AES等）</li>\n<li>非对称加密：有公钥和私钥。公钥加密数据需要私钥解密；私钥加密需要公钥解密。（RSA、DSA等）</li>\n</ul><h3 id=\"get和post\">GET和POST<a href=\"#get和post\" title=\"GET和POST\"></a></h3><p>GET和POST本质上就是TCP/IP，无差别。但它作为一种语义规范。</p>\n<ul><li>GET在URL里说明要请求的参数；POST传输的参数不在URL里出现，而是在request body里。请求头多出来Content-Type和Content-Length字段。（但你要在GET加上request body，给POST带上URL参数也是完全可行）</li>\n<li>GET方式，客户端会把header和data一并发出去，只产生一个TCP数据包；POST方式，客户端先发送header，服务器响应100 continue，客户端再发送data，服务器响应200 ok，产生两个TCP数据包（并非所有的都会发两次包，Firefox就只发送一次）。</li>\n<li>GET是幂等的，请求不会改变资源的状态（这里强调的是调用一次和n次都具有相同的副作用，而不是每次GET的结果都相同）；POST不具有幂等性。</li>\n</ul><h3 id=\"常见状态码\">常见状态码<a href=\"#常见状态码\" title=\"常见状态码\"></a></h3><ul><li>200 OK - 客户端请求成功</li>\n<li>301 - 资源（网页等）被永久转移到其它URL</li>\n<li>302 - 临时跳转</li>\n<li>400 Bad Request - 客户端请求有语法错误，不能被服务器所理解</li>\n<li>401 Unauthorized - 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</li>\n<li>403 Forbidden - 服务器拒绝</li>\n<li>404 - 请求资源不存在，可能是输入了错误的URL</li>\n<li>500 - 服务器内部发生了不可预期的错误</li>\n<li>503 Server Unavailable - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常。</li>\n</ul><h2 id=\"从-url-输入到页面出现经历了什么？\">从 URL 输入到页面出现经历了什么？<a href=\"#从-url-输入到页面出现经历了什么？\" title=\"从 URL 输入到页面出现经历了什么？\"></a></h2><ul><li>DNS 解析：将域名解析成 IP 地址（浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP-&gt;根）</li>\n<li>请求连接：TCP 三次握手</li>\n<li>发送 HTTP 请求</li>\n<li>服务器处理请求并返回 HTTP 报文</li>\n<li>浏览器解析渲染页面</li>\n<li>断开连接：TCP 四次挥手</li>\n</ul>","next":{"title":"关于并发","link":"2020/07/13/关于并发"},"plink":"https://cxccao.github.io/2020/07/14/关于计算机网络/","toc":[{"id":"计算机网络","title":"计算机网络","index":"1","children":[{"id":"网络层次","title":"网络层次","index":"1.1"},{"id":"tcpip","title":"TCP&#x2F;IP","index":"1.2","children":[{"id":"三次握手和四次挥手原理","title":"三次握手和四次挥手原理","index":"1.2.1"},{"id":"为什么要三次握手？","title":"为什么要三次握手？","index":"1.2.2"},{"id":"为什么是四次挥手、为什么要等待2msl？","title":"为什么是四次挥手、为什么要等待2MSL？","index":"1.2.3"},{"id":"如何保证可靠传输","title":"如何保证可靠传输","index":"1.2.4"},{"id":"流量控制","title":"流量控制","index":"1.2.5"},{"id":"拥塞控制","title":"拥塞控制","index":"1.2.6"},{"id":"和udp区别","title":"和UDP区别","index":"1.2.7"}]},{"id":"http和https","title":"HTTP和HTTPS","index":"1.3","children":[{"id":"http10和http11区别","title":"HTTP&#x2F;1.0和HTTP&#x2F;1.1区别","index":"1.3.1"},{"id":"http和https的区别","title":"HTTP和HTTPS的区别","index":"1.3.2"},{"id":"http报文结构","title":"HTTP报文结构","index":"1.3.3"},{"id":"https流程","title":"HTTPS流程","index":"1.3.4"},{"id":"get和post","title":"GET和POST","index":"1.3.5"},{"id":"常见状态码","title":"常见状态码","index":"1.3.6"}]},{"id":"从-url-输入到页面出现经历了什么？","title":"从 URL 输入到页面出现经历了什么？","index":"1.4"}]}],"copyright":{"author":"Shelton Chen","link":"<a href=\"https://cxccao.github.io/2020/07/14/关于计算机网络/\" title=\"关于计算机网络\">https://cxccao.github.io/2020/07/14/关于计算机网络/</a>","updated":"2020年7月20日","license":"署名-非商业性使用-相同方式共享 4.0 国际 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)"}}