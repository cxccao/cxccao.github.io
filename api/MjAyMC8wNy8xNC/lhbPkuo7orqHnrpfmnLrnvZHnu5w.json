{"title":"关于计算机网络","date":"2020-07-14T11:31:08.000Z","date_formatted":{"ll":"2020年7月14日","L":"2020/07/14","MM-DD":"07-14"},"link":"2020/07/14/关于计算机网络","tags":["计算机网络"],"updated":"2020-07-19T16:25:11.914Z","content":"<h1 id=\"计算机网络\">计算机网络<a href=\"#计算机网络\" title=\"计算机网络\"></a></h1><h2 id=\"网络层次\">网络层次<a href=\"#网络层次\" title=\"网络层次\"></a></h2><p>OSI将网络分为七层，TCP/IP有四层，折中取五层</p>\n<img src=\"/2020/07/14/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png\" class=\"\"><ol><li>物理层：主要定义物理设备标准，例如网线的接口类型、光线的接口类型、各种传输介质的传输速率等。他的主要作用是传入比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们通常所说的数模转换与模数转换）。这一层的数据叫做比特流。（RJ45、IEEE802.3）</li>\n<li>数据链路层：定义了如何让数据格式化进行传输，以及如何让控制对物理介质的访问。这一层通常还提供了错误检测和纠正，以保证数据的可靠传输。（VLAN、MAC）</li>\n<li>网络层：在位于不同地理位置的网络中的两个主机之间提供连接和路径选择。（IP、ICMP、ARP）</li>\n<li>传输层：定义了一些传输数据的协议和端口号（TCP、UDP）</li>\n<li>应用层：通过进程间的交互来完成特定网应用。（HTTP、DNS、FTP）</li>\n</ol><h2 id=\"tcp\">TCP<a href=\"#tcp\" title=\"TCP\"></a></h2><h3 id=\"三次握手和四次挥手原理\">三次握手和四次挥手原理<a href=\"#三次握手和四次挥手原理\" title=\"三次握手和四次挥手原理\"></a></h3><ul><li><p>三次握手：客户端发送请求连接数据报，首部 SYN = 1，序列号 x，进入 SYN-SENT 状态；服务器同意请求，发送同意连接数据报，首部 SYN = 1，ACK = 1，序列号 y，确认号 x + 1，进入 SYN-RECV 状态；客户端发送确认数据报，ACK = 1，序列号 x + 1，确认号 y + 1，进入 ESTABLISHED 状态；服务器收到数据报，进入 ESTABLISHED 状态。至此双方已建立链接。</p>\n</li>\n<li><p>四次挥手：客户端发送释放连接数据报，首部 FIN = 1，序列号 u，进入 FIN-WAIT-1状态；服务器发出确认数据报，首部 ACK = 1，序列号  v，确认号 u + 1，进入 CLOSED-WAIT 状态；客户端进入FIN-WAIT-2状态；服务器发送完最后的数据后，发出释放连接数据报，首部 FIN = 1，ACK = 1，序列号 w，确认号 u + 1，进入 LAST-ACK状态；客户端发送确认数据报，首部 ACK = 1，序列号 u + 1，确认号  w + 1，进入TIME-WAIT状态；服务器进入CLOSED状态；客户端等待2MSL后，进入CLOSED状态。至此双方结束链接。</p>\n</li>\n</ul><h3 id=\"为什么要三次握手？\">为什么要三次握手？<a href=\"#为什么要三次握手？\" title=\"为什么要三次握手？\"></a></h3><p>很遗憾，网上许多介绍都是想当然的错误而已。三次握手并不是要确认自己和对方的发送和接收正常。读一下<a href=\"https://www.ietf.org/rfc/rfc793.txt\" target=\"_blank\">RFC793</a>（TCP传输控制协议），可以发现在3.3 Sequence Numbers中讲到了：</p>\n<blockquote>\n<p>A fundamental notion in the design is that every octet of data sent over a TCP connection has a sequence number. Since every octet is sequenced, each of them can be acknowledged. The acknowledgment mechanism employed is cumulative so that an acknowledgment of sequence number X indicates that all octets up to but not including X have been received.</p>\n</blockquote>\n<p>TCP可靠连接有许多原因，最主要的就是这条：序列号。</p>\n<blockquote>\n<p>A three way handshake is necessary because sequence numbers are not tied to a global clock in the network, and TCPs may have different mechanisms for picking the ISN’s. The receiver of the first SYN has no way of knowing whether the segment was an old delayed one or not, unless it remembers the last sequence number used on the connection (which is not always possible), and so it must ask the sender to verify this SYN. The three way handshake and the advantages of a clock-driven scheme are discussed in [3].</p>\n</blockquote>\n<p>所以，三次握手的真正原因是：<strong>TCP 需要序列号（seq）来做可靠重传或接收，而避免连接复用时无法分辨出序列号是延迟或者是旧链接的序列号，因此需要三次握手来约定确定双方的 Initial Sequence Number（初始序列号）。</strong></p>\n<h3 id=\"为什么是四次挥手、为什么要等待2msl？\">为什么是四次挥手、为什么要等待2MSL？<a href=\"#为什么是四次挥手、为什么要等待2msl？\" title=\"为什么是四次挥手、为什么要等待2MSL？\"></a></h3><p>TCP是全双工通信，故每一个方向都必须单独进行关闭。当一方完毕它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN仅仅意味着这一方向上没有数据流动。一个TCP连接在收到一个FIN后仍能发送数据。</p>\n<p>保证客户端发送的最后一个ACK报文能够到达服务器。服务器已经发送了FIN+ACK报文请求断开了，客户端还没有回应，应该是发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器；在这个2MSL时间中，可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>\n<h3 id=\"如何保证可靠传输\">如何保证可靠传输<a href=\"#如何保证可靠传输\" title=\"如何保证可靠传输\"></a></h3><ul><li>数据被TCP分割成最适合的大小</li>\n<li><strong>序列号！！！</strong></li>\n<li>校验和 </li>\n<li>流量控制</li>\n<li>拥塞控制</li>\n<li>超时重传</li>\n<li>ARQ协议</li>\n</ul><h3 id=\"流量控制\">流量控制<a href=\"#流量控制\" title=\"流量控制\"></a></h3><p>为了控制发送方发送速率，保证接收方来得及接收。</p>\n<p>TCP通过滑动窗口来实现流量控制。 </p>\n<p>接收方发送的确认报文中的窗口字段可以用来告诉发送方窗口大小，从而影响发送方的发送速率。将窗口置零，则发送方不能发送数据。</p>\n<h3 id=\"拥塞控制\">拥塞控制<a href=\"#拥塞控制\" title=\"拥塞控制\"></a></h3><p>TCP发送方维护一个拥塞窗口（cwnd）变量。动态变化。采用四种算法来控制：<strong>慢开始</strong>、<strong>拥塞避免</strong>、<strong>快重传、</strong>快恢复**。</p>\n<ul><li>慢开始：cwnd初始值为1，每经过一个传播轮次，cwnd翻倍。设置一个慢开始阈值 ssthresh。</li>\n<li>拥塞避免：cwnd &gt;= ssthresh 时采用。每经过一个传播轮次，cwnd 线性加一。</li>\n<li>快重传：发送方尽快进行重传，而不是等超时重传计时器超时再重传；要求接收方收到数据立即发送确认；接收方收到失序的报文段立即发出已收到报文段的重复确认；发送方收到3个连续的重复确认，就将缺失的报文段立即重传。</li>\n<li>快恢复：将 cwnd 和 ssthresh 调整为当前窗口一半，开始拥塞避免算法。</li>\n</ul><h3 id=\"和udp区别\">和UDP区别<a href=\"#和udp区别\" title=\"和UDP区别\"></a></h3><p>TCP：面向连接、可靠、资源开销多</p>\n<p>UDP：无连接、不可靠、资源开销少</p>\n<h2 id=\"http和https\">HTTP和HTTPS<a href=\"#http和https\" title=\"HTTP和HTTPS\"></a></h2><h3 id=\"http短连接、长连接\">HTTP短连接、长连接<a href=\"#http短连接、长连接\" title=\"HTTP短连接、长连接\"></a></h3>","next":{"title":"关于并发","link":"2020/07/13/关于并发"},"plink":"https://cxccao.github.io/2020/07/14/关于计算机网络/","toc":[{"id":"计算机网络","title":"计算机网络","index":"1","children":[{"id":"网络层次","title":"网络层次","index":"1.1"},{"id":"tcp","title":"TCP","index":"1.2","children":[{"id":"三次握手和四次挥手原理","title":"三次握手和四次挥手原理","index":"1.2.1"},{"id":"为什么要三次握手？","title":"为什么要三次握手？","index":"1.2.2"},{"id":"为什么是四次挥手、为什么要等待2msl？","title":"为什么是四次挥手、为什么要等待2MSL？","index":"1.2.3"},{"id":"如何保证可靠传输","title":"如何保证可靠传输","index":"1.2.4"},{"id":"流量控制","title":"流量控制","index":"1.2.5"},{"id":"拥塞控制","title":"拥塞控制","index":"1.2.6"},{"id":"和udp区别","title":"和UDP区别","index":"1.2.7"}]},{"id":"http和https","title":"HTTP和HTTPS","index":"1.3","children":[{"id":"http短连接、长连接","title":"HTTP短连接、长连接","index":"1.3.1"}]}]}],"copyright":{"author":"Shelton Chen","link":"<a href=\"https://cxccao.github.io/2020/07/14/关于计算机网络/\" title=\"关于计算机网络\">https://cxccao.github.io/2020/07/14/关于计算机网络/</a>","updated":"2020年7月20日","license":"署名-非商业性使用-相同方式共享 4.0 国际 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)"}}