{"title":"关于计算机网络","date":"2020-07-14T11:31:08.000Z","date_formatted":{"ll":"2020年7月14日","L":"2020/07/14","MM-DD":"07-14"},"link":"2020/07/14/关于计算机网络","tags":["计算机网络"],"updated":"2020-08-15T08:03:42.385Z","content":"<h1 id=\"计算机网络\">计算机网络<a href=\"#计算机网络\" title=\"计算机网络\"></a></h1><h2 id=\"网络层次\">网络层次<a href=\"#网络层次\" title=\"网络层次\"></a></h2><p>OSI 将网络分为七层，TCP/IP 有四层，折中取五层</p>\n<img src=\"/2020/07/14/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png\" class=\"\"><ol><li>物理层：主要定义物理设备标准，例如网线的接口类型、光线的接口类型、各种传输介质的传输速率等。他的主要作用是传入比特流（就是由 1、0 转化为电流强弱来进行传输，到达目的地后再转化为 1、0，也就是我们通常所说的数模转换与模数转换）。这一层的数据叫做比特流。（RJ45、IEEE802.3）</li>\n<li>数据链路层：定义了如何让数据格式化进行传输，以及如何让控制对物理介质的访问。这一层通常还提供了错误检测和纠正，以保证数据的可靠传输。（VLAN、MAC）</li>\n<li>网络层：在位于不同地理位置的网络中的两个主机之间提供连接和路径选择。（IP、ICMP、ARP）</li>\n<li>传输层：定义了一些传输数据的协议和端口号（TCP、UDP）</li>\n<li>应用层：通过进程间的交互来完成特定网应用。（HTTP、DNS、FTP）</li>\n</ol><h2 id=\"tcpip\">TCP/IP<a href=\"#tcpip\" title=\"TCP/IP\"></a></h2><h3 id=\"三次握手和四次挥手原理\">三次握手和四次挥手原理<a href=\"#三次握手和四次挥手原理\" title=\"三次握手和四次挥手原理\"></a></h3><ul><li><p>三次握手：客户端发送请求连接数据报，首部 SYN = 1，序列号 x，进入 SYN-SENT 状态；服务器同意请求，发送同意连接数据报，首部 SYN = 1，ACK = 1，序列号 y，确认号 x + 1，进入 SYN-RECV 状态；客户端发送确认数据报，ACK = 1，序列号 x + 1，确认号 y + 1，进入 ESTABLISHED 状态；服务器收到数据报，进入 ESTABLISHED 状态。至此双方已建立链接。</p>\n</li>\n<li><p>四次挥手：客户端发送释放连接数据报，首部 FIN = 1，序列号 u，进入 FIN-WAIT-1 状态；服务器发出确认数据报，首部 ACK = 1，序列号  v，确认号 u + 1，进入 CLOSED-WAIT 状态；客户端进入 FIN-WAIT-2 状态；服务器发送完最后的数据后，发出释放连接数据报，首部 FIN = 1，ACK = 1，序列号 w，确认号 u + 1，进入 LAST-ACK 状态；客户端发送确认数据报，首部 ACK = 1，序列号 u + 1，确认号  w + 1，进入 TIME-WAIT 状态；服务器进入 CLOSED 状态；客户端等待2MSL 后，进入 CLOSED 状态。至此双方结束链接。</p>\n</li>\n</ul><h3 id=\"为什么要三次握手？\">为什么要三次握手？<a href=\"#为什么要三次握手？\" title=\"为什么要三次握手？\"></a></h3><p>很遗憾，网上许多介绍都是想当然的错误而已。三次握手并不是要确认自己和对方的发送和接收正常。读一下<a href=\"https://www.ietf.org/rfc/rfc793.txt\" target=\"_blank\">RFC793</a>（TCP传输控制协议），可以发现在 3.3 Sequence Numbers 中讲到了：</p>\n<blockquote>\n<p>A fundamental notion in the design is that every octet of data sent over a TCP connection has a sequence number. Since every octet is sequenced, each of them can be acknowledged. The acknowledgment mechanism employed is cumulative so that an acknowledgment of sequence number X indicates that all octets up to but not including X have been received.</p>\n</blockquote>\n<p>TCP 可靠连接有许多原因，最主要的就是这条：序列号。</p>\n<blockquote>\n<p>A three way handshake is necessary because sequence numbers are not tied to a global clock in the network, and TCPs may have different mechanisms for picking the ISN’s. The receiver of the first SYN has no way of knowing whether the segment was an old delayed one or not, unless it remembers the last sequence number used on the connection (which is not always possible), and so it must ask the sender to verify this SYN. The three way handshake and the advantages of a clock-driven scheme are discussed in [3].</p>\n</blockquote>\n<p>所以，三次握手的真正原因是：<strong>TCP 需要序列号（seq）来做可靠重传或接收，而避免连接复用时无法分辨出序列号是延迟或者是旧链接的序列号，因此需要三次握手来约定确定双方的 Initial Sequence Number（初始序列号）。</strong></p>\n<p><strong>四次握手的情况</strong></p>\n<ul><li>A 发送 SYN + A’s ISN 给 B</li>\n<li>B 收到，回复 ACK + 确认号 给 A</li>\n<li>B 发送 SYN + B’s ISN 给 A</li>\n<li>A 收到，回复 ACK + 确认号 给 B</li>\n</ul><p>很显然，第二步和第三步可以合并。</p>\n<p><strong>二次握手的情况</strong></p>\n<ul><li>A 发送 SYN + A’s ISN 给 B</li>\n<li>B 收到，回复 SYN + ACK + 确认号 + B’s ISN 给 A</li>\n</ul><p>A 确认 B 收到了，B 不能确认 A 收到了，无法保证传输可靠性。</p>\n<p><strong>旧 SYN 信号的情况</strong></p>\n<ul><li>A 的旧 SYN 到达了 B，B 进入 SYN-RCVD 状态</li>\n<li>B 回复 SYN + ACK + 确认号 + B‘s ISN 给 A</li>\n<li>A 判断 B 发过来的确认号不正确，返回 RST</li>\n<li>B 收到 RST，恢复到 LISTEN 状态</li>\n<li>A 的新 SYN 到达了 B，开始正常三次握手</li>\n</ul><h3 id=\"为什么是四次挥手、为什么要等待2msl？\">为什么是四次挥手、为什么要等待2MSL？<a href=\"#为什么是四次挥手、为什么要等待2msl？\" title=\"为什么是四次挥手、为什么要等待2MSL？\"></a></h3><p>TCP 是全双工通信，故每一个方向都必须单独进行关闭。当一方完毕它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 仅仅意味着这一方向上没有数据流动。一个 TCP 连接在收到一个 FIN 后仍能发送数据。</p>\n<p>保证客户端发送的最后一个 ACK 报文能够到达服务器。服务器已经发送了 FIN+ACK 报文请求断开了，客户端还没有回应，应该是发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2MSL 计时器；在这个 2MSL 时间中，可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>\n<h3 id=\"如何保证可靠传输\">如何保证可靠传输<a href=\"#如何保证可靠传输\" title=\"如何保证可靠传输\"></a></h3><ul><li>数据被 TCP 分割成最适合的大小</li>\n<li><strong>序列号！！！</strong></li>\n<li>校验和 </li>\n<li>流量控制</li>\n<li>拥塞控制</li>\n<li>超时重传</li>\n<li>ARQ协议</li>\n</ul><h3 id=\"流量控制\">流量控制<a href=\"#流量控制\" title=\"流量控制\"></a></h3><p>为了控制发送方发送速率，保证接收方来得及接收。</p>\n<p>TCP 通过滑动窗口来实现流量控制。 </p>\n<p>接收方发送的确认报文中的窗口字段可以用来告诉发送方窗口大小，从而影响发送方的发送速率。将窗口置零，则发送方不能发送数据。</p>\n<h3 id=\"拥塞控制\">拥塞控制<a href=\"#拥塞控制\" title=\"拥塞控制\"></a></h3><p>TCP 发送方维护一个拥塞窗口（cwnd）变量。动态变化。采用四种算法来控制：<strong>慢开始</strong>、<strong>拥塞避免</strong>、<strong>快重传</strong>、<strong>快恢复</strong>。</p>\n<ul><li><strong>慢开始</strong>：cwnd 初始值为 1，每经过一个传播轮次，cwnd 翻倍。设置一个慢开始阈值 ssthresh。</li>\n<li><strong>拥塞避免</strong>：cwnd &gt;= ssthresh 时采用。每经过一个传播轮次，cwnd 线性加一。</li>\n<li><strong>快重传</strong>：发送方尽快进行重传，而不是等超时重传计时器超时再重传；要求接收方收到数据立即发送确认；接收方收到失序的报文段立即发出已收到报文段的重复确认；发送方收到3个连续的重复确认，就将缺失的报文段立即重传。</li>\n<li><strong>快恢复</strong>：将 cwnd 和 ssthresh 调整为当前窗口一半，开始拥塞避免算法。</li>\n</ul><h3 id=\"和udp区别\">和UDP区别<a href=\"#和udp区别\" title=\"和UDP区别\"></a></h3><p>TCP：面向连接、可靠、资源开销多</p>\n<p>UDP：无连接、不可靠、资源开销少</p>\n<h2 id=\"http和https\">HTTP和HTTPS<a href=\"#http和https\" title=\"HTTP和HTTPS\"></a></h2><h3 id=\"http10和http11区别\">HTTP/1.0和HTTP/1.1区别<a href=\"#http10和http11区别\" title=\"HTTP/1.0和HTTP/1.1区别\"></a></h3><ul><li>在 HTTP/1.0 中默认使用短连接，每一次请求都需要重新建立连接（需要三握四挥开销）；HTTP/1.1 默认使用长连接，默认开启 keep-alive，有非流水线和流水线方式，前者收到响应后才能发送下一个请求，后者能连续发送请求。</li>\n<li>HTTP/1.1 新增 24 个状态响应码</li>\n<li>HTTP/1.0 使用 If-Modified-Since、Expires 来做缓存判断标准；HTTP/1.1 使用新增如 Entity tag、If-Unmodified-Since、If-Match、If-None-Match 来控制缓存策略。</li>\n<li>HTTP/1.0 中请求资源必须请求整个资源；HTTP/1.1 中在 header 中加入了 range 头域，允许只请求资源的某个部分。</li>\n</ul><h3 id=\"http20\">HTTP2.0<a href=\"#http20\" title=\"HTTP2.0\"></a></h3><ul><li><strong>二进制传输</strong>：在应用层和传输层之间增加一个二进制分帧层。HTTP2.0 会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码。其中 HTTP1.x 的头部信息会被封装到 Header 帧，request body 封装到 data 帧。</li>\n<li><strong>Header 压缩</strong>：维护【头部表】来跟踪和储存之前发送的头部，对于相同的头部不必再用过请求发送，只需发送一次。例如对统一资源的轮询请求，那么头部开销就是 0，此时所有头部自动使用之前请求发送的头部。</li>\n<li><strong>多路复用</strong>：帧是最小数据单位，流是多个帧组成的数据流。一个 TCP 连接可以同时发送多个请求，乱序发送，到对端后根据每个帧首部的流标识符重新组装。</li>\n<li><strong>服务器推送</strong>：服务器可以在客户端某个请求后，主动推送其它资源。</li>\n<li><strong>安全性</strong>：因为 Client 和 Server 之间在确立使用是否使用 HTTP2.0 之前，需要确认是否支持，这里需要有个协商过程。我们修改 HTTP1.x 就是为了降低延迟，所以协商花费的耗时是无法接收的。所以在 SSL 层完成这个协商是比较好的解决方案。各浏览器只实现了基于 SSL 的 HTTP2.0，但协议没有强制必须用 SSL。</li>\n</ul><h3 id=\"http和https的区别\">HTTP和HTTPS的区别<a href=\"#http和https的区别\" title=\"HTTP和HTTPS的区别\"></a></h3><ul><li>HTTPS 协议需要到 CA 申请证书。</li>\n<li>HTTP 协议运行在 TCP 之上，所有传输内容都是明文；HTTPS 运行在 SSL/TLS 上，SSL/TLS 运行在 TCP 之上，所有传输内容都经过加密。</li>\n<li>HTTP 端口为 80；HTTPS 端口为 443。</li>\n<li>HTTPS 比 HTTP 更消耗资源。</li>\n</ul><h3 id=\"http报文结构\">HTTP报文结构<a href=\"#http报文结构\" title=\"HTTP报文结构\"></a></h3><ul><li><strong>请求行/响应行</strong>：Method Request-URI HTTP-Version；HTTP-Version Status-Code Reason-Phrase</li>\n<li><strong>请求头/响应头</strong>：Host、User-Agent、Accept…；Location、Server…</li>\n<li><strong>报文主体</strong></li>\n</ul><h3 id=\"https流程\">HTTPS流程<a href=\"#https流程\" title=\"HTTPS流程\"></a></h3><img src=\"/2020/07/14/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS%E6%B5%81%E7%A8%8B.png\" class=\"\"><ul><li><strong>对称加密</strong>：加密和解密都是用同一个密钥。（DES、AES等）</li>\n<li><strong>非对称加密</strong>：有公钥和私钥。公钥加密数据需要私钥解密；私钥加密需要公钥解密。（RSA、DSA等）</li>\n</ul><h3 id=\"get和post\">GET和POST<a href=\"#get和post\" title=\"GET和POST\"></a></h3><p>GET 和 POST 本质上就是 TCP/IP，无差别。但它作为一种语义规范。</p>\n<ul><li>GET 在 URL 里说明要请求的参数；POST 传输的参数不在 URL 里出现，而是在 request body 里。请求头多出来 Content-Type 和 Content-Length 字段。（但你要在 GET 加上 request body，给 POST 带上 URL 参数也是完全可行）</li>\n<li>GET 方式，客户端会把 header 和 data 一并发出去，只产生一个 TCP 数据包；POST 方式，客户端先发送 header，服务器响应 100 continue，客户端再发送 data，服务器响应 200 ok，产生两个 TCP 数据包（并非所有的都会发两次包，Firefox 就只发送一次）。</li>\n<li>GET 是幂等的，请求不会改变资源的状态（这里强调的是调用一次和 n 次都具有相同的状态，而不是每次 GET 的结果都相同）；POST 不具有幂等性。</li>\n</ul><h3 id=\"常见状态码\">常见状态码<a href=\"#常见状态码\" title=\"常见状态码\"></a></h3><ul><li>200 OK - 客户端请求成功</li>\n<li>301 Moved Permanently  - 资源（网页等）被永久转移到其它URL</li>\n<li>302 Moved Temporarily - 临时跳转</li>\n<li>400 Bad Request - 客户端请求有语法错误，不能被服务器所理解</li>\n<li>401 Unauthorized - 请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用</li>\n<li>403 Forbidden - 服务器拒绝</li>\n<li>404 Not Found - 请求资源不存在，可能是输入了错误的 URL</li>\n<li>500 Internal Server Error - 服务器内部发生了不可预期的错误</li>\n<li>503 Server Unavailable - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常。</li>\n</ul><h2 id=\"从-url-输入到页面出现经历了什么？\">从 URL 输入到页面出现经历了什么？<a href=\"#从-url-输入到页面出现经历了什么？\" title=\"从 URL 输入到页面出现经历了什么？\"></a></h2><ul><li>DNS 解析：将域名解析成 IP 地址（浏览器缓存 -&gt; 系统缓存 -&gt; 路由器缓存 -&gt; ISP -&gt; 根）</li>\n<li>请求连接：TCP 三次握手</li>\n<li>发送 HTTP 请求</li>\n<li>服务器处理请求并返回 HTTP 报文</li>\n<li>浏览器解析渲染页面</li>\n<li>断开连接：TCP 四次挥手</li>\n</ul>","prev":{"title":"关于数据库","link":"2020/07/27/关于数据库"},"next":{"title":"关于并发","link":"2020/07/13/关于并发"},"plink":"https://cxccao.github.io/2020/07/14/关于计算机网络/","toc":[{"id":"计算机网络","title":"计算机网络","index":"1","children":[{"id":"网络层次","title":"网络层次","index":"1.1"},{"id":"tcpip","title":"TCP&#x2F;IP","index":"1.2","children":[{"id":"三次握手和四次挥手原理","title":"三次握手和四次挥手原理","index":"1.2.1"},{"id":"为什么要三次握手？","title":"为什么要三次握手？","index":"1.2.2"},{"id":"为什么是四次挥手、为什么要等待2msl？","title":"为什么是四次挥手、为什么要等待2MSL？","index":"1.2.3"},{"id":"如何保证可靠传输","title":"如何保证可靠传输","index":"1.2.4"},{"id":"流量控制","title":"流量控制","index":"1.2.5"},{"id":"拥塞控制","title":"拥塞控制","index":"1.2.6"},{"id":"和udp区别","title":"和UDP区别","index":"1.2.7"}]},{"id":"http和https","title":"HTTP和HTTPS","index":"1.3","children":[{"id":"http10和http11区别","title":"HTTP&#x2F;1.0和HTTP&#x2F;1.1区别","index":"1.3.1"},{"id":"http20","title":"HTTP2.0","index":"1.3.2"},{"id":"http和https的区别","title":"HTTP和HTTPS的区别","index":"1.3.3"},{"id":"http报文结构","title":"HTTP报文结构","index":"1.3.4"},{"id":"https流程","title":"HTTPS流程","index":"1.3.5"},{"id":"get和post","title":"GET和POST","index":"1.3.6"},{"id":"常见状态码","title":"常见状态码","index":"1.3.7"}]},{"id":"从-url-输入到页面出现经历了什么？","title":"从 URL 输入到页面出现经历了什么？","index":"1.4"}]}],"copyright":{"author":"Shelton Chen","link":"<a href=\"https://cxccao.github.io/2020/07/14/关于计算机网络/\" title=\"关于计算机网络\">https://cxccao.github.io/2020/07/14/关于计算机网络/</a>","updated":"2020年8月15日","license":"署名-非商业性使用-相同方式共享 4.0 国际 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)"}}