{"title":"关于JVM垃圾回收","date":"2020-07-12T09:12:20.000Z","date_formatted":{"ll":"2020年7月12日","L":"2020/07/12","MM-DD":"07-12"},"link":"2020/07/12/关于JVM垃圾回收","tags":["JVM"],"updated":"2020-07-31T06:14:23.328Z","content":"<h1 id=\"关于jvm垃圾回收\">关于JVM垃圾回收<a href=\"#关于jvm垃圾回收\" title=\"关于JVM垃圾回收\"></a></h1><h2 id=\"堆\">堆<a href=\"#堆\" title=\"堆\"></a></h2><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1（Eden 区 -&gt; Survivor 区后对象的初始年龄变为 1），当它的年龄增加到一定程度（默认为 15 岁，看具体垃圾收集器，比如 CMS 为 6），就会被晋升到老年代中。</p>\n<img src=\"/2020/07/12/%E5%85%B3%E4%BA%8EJVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%A0%86%E7%A9%BA%E9%97%B4%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png\" class=\"\"><p>经过这次 GC 后，Eden 区和 “From” 区已经被清空。这个时候，”From” 和 “To” 会交换他们的角色，也就是新的 “To” 就是上次 GC 前的 “From”，新的 “From” 就是上次 GC 前的 “To” 。不管怎样，都会保证名为 “To” 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到 “To” 区被填满，”To” 区被填满之后，会将所有对象移动到老年代中。</p>\n<h2 id=\"对象分配策略\">对象分配策略<a href=\"#对象分配策略\" title=\"对象分配策略\"></a></h2><ul><li><p>优先在 Eden 区分配</p>\n</li>\n<li><p>大对象（字符串、数组等）直接进入老年代</p>\n</li>\n<li><p>长期存活对象进入老年代</p>\n</li>\n<li><p>动态对象年龄判定</p>\n<ul><li><blockquote>\n<p>“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p>\n</blockquote>\n</li>\n</ul></li>\n</ul><h2 id=\"判断对象死亡\">判断对象死亡<a href=\"#判断对象死亡\" title=\"判断对象死亡\"></a></h2><h2 id=\"引用计数法\">引用计数法<a href=\"#引用计数法\" title=\"引用计数法\"></a></h2><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p>\n<p>简单实现效率高，但没人用，因为它解决不了循环引用问题。</p>\n<h3 id=\"可达性分析算法\">可达性分析算法<a href=\"#可达性分析算法\" title=\"可达性分析算法\"></a></h3><p>这个算法的基本思想就是通过一系列的称为 <strong>GC Roots</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 <strong>GC Roots</strong> 没有任何引用链相连的话，则证明此对象是不可用的。</p>\n<p>可作为 <strong>GC Roots</strong> 的对象包括下面几种</p>\n<ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>\n<li>本地方法栈（Native 方法）中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n</ul><h3 id=\"关于引用\">关于引用<a href=\"#关于引用\" title=\"关于引用\"></a></h3><div class=\"φcz\"><div class=\"φdb\"><table><thead><tr>\n<th align=\"center\">引用类型</th><th align=\"center\">被垃圾回收时间</th><th align=\"center\">用途</th><th align=\"center\">生存时间</th></tr>\n</thead><tbody><tr>\n<td align=\"center\">强引用</td><td align=\"center\">从来不会</td><td align=\"center\">对象一般状态</td><td align=\"center\">JVM停止运行时终止</td></tr>\n<tr>\n<td align=\"center\">软引用</td><td align=\"center\">当内存不足时</td><td align=\"center\">对象缓存</td><td align=\"center\">内存不足时终止</td></tr>\n<tr>\n<td align=\"center\">弱引用</td><td align=\"center\">正常GC时</td><td align=\"center\">对象缓存</td><td align=\"center\">GC后终止</td></tr>\n<tr>\n<td align=\"center\">虚引用</td><td align=\"center\">正常GC时</td><td align=\"center\">跟踪对象的垃圾回收</td><td align=\"center\">GC后终止</td></tr>\n</tbody></table></div></div><h3 id=\"对象真正死亡时期\">对象真正死亡时期<a href=\"#对象真正死亡时期\" title=\"对象真正死亡时期\"></a></h3><ol><li>如果对象进行可达性分析之后没发现与 GC Roots 相连的引用链，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行 finalize() 方法。如果对象有必要执行 finalize() 方法，则被放入 F-Queue 队列中。</li>\n<li>GC 对 F-Queue 队列中的对象进行二次标记。如果对象在 finalize() 方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。</li>\n</ol><h2 id=\"垃圾回收算法\">垃圾回收算法<a href=\"#垃圾回收算法\" title=\"垃圾回收算法\"></a></h2><h3 id=\"标记-清除算法\">标记-清除算法<a href=\"#标记-清除算法\" title=\"标记-清除算法\"></a></h3><p>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。缺点时会产生大量碎片。</p>\n<h3 id=\"标记-复制算法\">标记-复制算法<a href=\"#标记-复制算法\" title=\"标记-复制算法\"></a></h3><p>将内存分为大小相同的两块，每次使用其中一块。当一块内存用完后，就将存活的对象复制到另一块，把原来使用的空间清除掉。缺点是可用空间只有一半。</p>\n<h3 id=\"标记-整理算法\">标记-整理算法<a href=\"#标记-整理算法\" title=\"标记-整理算法\"></a></h3><p>首先标记出所有需要回收的对象，在标记完成后将存活对象往一段移动，清理掉边界以外的空间。</p>\n<h3 id=\"分代收集算法\">分代收集算法<a href=\"#分代收集算法\" title=\"分代收集算法\"></a></h3><p>我们可以根据各个年代的特点选择合适的垃圾收集算法。</p>\n<p>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p>\n<h2 id=\"垃圾收集器\">垃圾收集器<a href=\"#垃圾收集器\" title=\"垃圾收集器\"></a></h2><h3 id=\"serial收集器\">Serial收集器<a href=\"#serial收集器\" title=\"Serial收集器\"></a></h3><p>只会用一条线程区完成垃圾收集工作，并且工作时 <strong>“Stop The World”</strong> 。</p>\n<p>采用标记-复制算法。</p>\n<p>简单且高效。</p>\n<h3 id=\"parnew收集器\">ParNew收集器<a href=\"#parnew收集器\" title=\"ParNew收集器\"></a></h3><p>Serial收集器的多线程版本。</p>\n<p>采用标记-复制算法。</p>\n<h3 id=\"parallel-scavenge收集器\">Parallel Scavenge收集器<a href=\"#parallel-scavenge收集器\" title=\"Parallel Scavenge收集器\"></a></h3><p>目标是达到一个可控制的吞吐量。Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量。可交给虚拟机自适应调节。</p>\n<p>采用标记-复制算法。</p>\n<h3 id=\"serial-old收集器\">Serial Old收集器<a href=\"#serial-old收集器\" title=\"Serial Old收集器\"></a></h3><p>Serial 收集器的老年代版本。</p>\n<p>采用标记-整理算法。</p>\n<h3 id=\"parallel-old收集器\">Parallel Old收集器<a href=\"#parallel-old收集器\" title=\"Parallel Old收集器\"></a></h3><p>Parallel Scavenge 收集器的老年代版本。</p>\n<p>采用标记-整理算法。</p>\n<h3 id=\"cms收集器\">CMS收集器<a href=\"#cms收集器\" title=\"CMS收集器\"></a></h3><p>是一种以获取最短回收停顿时间为目标的收集器。是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。过程分为四个步骤：</p>\n<ul><li>初始标记（会产生停顿）：记录下直接与 root 相连的对象，速度很快。</li>\n<li>并发标记：同时开启GC和用户线程，标记全部对象。</li>\n<li>重新标记：由于并发标记时，用户线程依然运行，因此在正式清理前，再做修正</li>\n<li>并发清除：开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>\n</ul><p>优点：并发收集、低停顿</p>\n<p>缺点：CPU资源敏感、产生内存碎片、清理不彻底</p>\n<h3 id=\"g1收集器\">G1收集器<a href=\"#g1收集器\" title=\"G1收集器\"></a></h3><p>是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器。以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征。</p>\n<p>G1 把连续的堆划分为多个大小相等的独立区域（Region），每一个 Region 可以根据需要，扮演新生代的 Eden、Survivor，或者老年代。G1 对不同角色的 Region 采用不同策略去处理。</p>\n<ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 <strong>Stop-The-World</strong> 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让程序继续执行。</li>\n<li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>\n<li><strong>空间整合</strong>：与 CMS 的 <strong>“标记-清理”</strong> 算法不同，G1 从整体来看是基于 <strong>“标记-整理”</strong> 算法实现的收集器；从局部上来看是基于 <strong>“标记-复制”</strong> 算法实现的。</li>\n<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li>\n</ul><p>大致运作过程可划分为下面四个步骤：</p>\n<ul><li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象。需停顿线程，但时间很短。</li>\n<li>并发标记：从 GC Root 开始对堆中的对象进行可达性分析。</li>\n<li>最终标记：处理并发标记阶段发生变更的对象，需停顿线程。</li>\n<li>筛选回收：对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划。</li>\n</ul><p>JDK9 开始，G1 已成为 JVM 中默认垃圾收集器。</p>\n","prev":{"title":"类的生命周期","link":"2020/07/13/类的生命周期"},"next":{"title":"关于Java内存区域","link":"2020/07/11/关于Java内存区域"},"plink":"https://cxccao.github.io/2020/07/12/关于JVM垃圾回收/","toc":[{"id":"关于jvm垃圾回收","title":"关于JVM垃圾回收","index":"1","children":[{"id":"堆","title":"堆","index":"1.1"},{"id":"对象分配策略","title":"对象分配策略","index":"1.2"},{"id":"判断对象死亡","title":"判断对象死亡","index":"1.3"},{"id":"引用计数法","title":"引用计数法","index":"1.4","children":[{"id":"可达性分析算法","title":"可达性分析算法","index":"1.4.1"},{"id":"关于引用","title":"关于引用","index":"1.4.2"},{"id":"对象真正死亡时期","title":"对象真正死亡时期","index":"1.4.3"}]},{"id":"垃圾回收算法","title":"垃圾回收算法","index":"1.5","children":[{"id":"标记-清除算法","title":"标记-清除算法","index":"1.5.1"},{"id":"标记-复制算法","title":"标记-复制算法","index":"1.5.2"},{"id":"标记-整理算法","title":"标记-整理算法","index":"1.5.3"},{"id":"分代收集算法","title":"分代收集算法","index":"1.5.4"}]},{"id":"垃圾收集器","title":"垃圾收集器","index":"1.6","children":[{"id":"serial收集器","title":"Serial收集器","index":"1.6.1"},{"id":"parnew收集器","title":"ParNew收集器","index":"1.6.2"},{"id":"parallel-scavenge收集器","title":"Parallel Scavenge收集器","index":"1.6.3"},{"id":"serial-old收集器","title":"Serial Old收集器","index":"1.6.4"},{"id":"parallel-old收集器","title":"Parallel Old收集器","index":"1.6.5"},{"id":"cms收集器","title":"CMS收集器","index":"1.6.6"},{"id":"g1收集器","title":"G1收集器","index":"1.6.7"}]}]}],"copyright":{"author":"Shelton Chen","link":"<a href=\"https://cxccao.github.io/2020/07/12/关于JVM垃圾回收/\" title=\"关于JVM垃圾回收\">https://cxccao.github.io/2020/07/12/关于JVM垃圾回收/</a>","updated":"2020年7月31日","license":"署名-非商业性使用-相同方式共享 4.0 国际 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)"}}